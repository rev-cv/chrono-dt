 python-модуль для упрощения работы со временем

# CHRONO
```python
from chrono import Chrono
```

## Создание объекта chrono
При создания объекта вызывается метод `set()`.
```python
# ↓ создать объект с текущим локальным временем
c = Chrono()

# ↓ создать объект передав год, месяц, день, час, минуты, секунды
#не переданным значениям будут проставлены минимальные возможные значение
c = Chrono(2021, 2, 15, 12) # → 2021-02-15 00:00:00

# ↓ создать объект передав строку
c = Chrono("2021-02-15 12:00") # → 2021-02-15 00:00:00

# создать объект передав в него chrono другой объект
c = Chrono(
	Chrono("2021-02-15 12:00")
) # → 2021-02-15 00:00:00

# создать объект передав в него datetime
c = Chrono(datetime.datetime(2021, 2, 15, 0, 0, 0))

# создать объект передав в него QDateTime
c = Chrono(QDateTime)

# создать объект передав в него QDate и опционально QTime
c = Chrono(QDate, QTime)

# создать объект передав в него время в формате UnixEpoh
c = Chrono(int(UnixEpoh))
```

Если Chrono не будет заполнен при создании и планируется заполнить его в дальнейшем при помощи методов типа «setter», можно запретить выполнение метода `set()`.
```python
c = Chrono(False)
```

## Методы типа «setter»
- `.set(y, m, d, H, M, S) -> self` — посредством анализа поступающих данных совмещает в себе функционал методов:
	- `.setDateTime(2022, 1, 15, 0, 25, 0)`
	- `.setDateTimeFromString("2022-05-12 00:25:00")`
	- `.setDT(datetime)`
	- `.setChrono(Chrono())`
	- `.setDateTime((2022, 5, 12, 0, 25, 0))`
	- `.setQDateTime(QDateTime)`
	- `.setQDate(QDate)` и `.setQTime(QTime)`
- `.setDate(y, m, d) -> self` — задает дату числами. Проводится проверка приводящая к Exception.
- `.setTime(H, M, S) -> self` — задает время числами. Проводится проверка приводящая к Exception.
- `.setDateTime(y, m, d, H, M, S) -> self` — задает дату и время числами. Проводится проверка приводящая к Exception.
- `.setDT(datetime) -> self` — принимает стандартное время в python (datetime.datetime).
- `.setDateTimeFromString(str) -> self` — принимает строку в которой, предполагается, наличие некоторого количества цифр имеющие какие-либо разделители или их не имеющие. Отсутствующие данные будут дополнены. Важным условием является последовательность `ymdHMS`. 
	- `"2022-11-14T02:25"` → `2022-11-14 02:25:00`
	- `"20221114022545"` → `2022-11-14 02:25:45`
- `.setTimeFromString() -> self` — работает аналогично `setDateTimeFromString`, но ищет только время.
- `.setNow() -> self`
- `.setUnixEpoch() -> self` — принимает секунды прошедшие с `1970-01-01 00:00:00`. Может принимать отрицательные секунды, что будет соответствовать времени, которое было до `1970-01-01 00:00:00`. Переводит часовой пояс в UTC.
- `.setISO(ISO) -> self` — принимает строку типа `2022-11-14T02:25:45`. Переводит часовой пояс в UTC.
- `.setByReGex(regex, str) -> self` — принимает строку, из которой по шаблону с именованными группами извлекаются данные о времени. Именованные группы:
	- `?P<year>`
	- `?P<month>`
	- `?P<month_text>` — месяц текстом на английском или русском, сокращенно или полностью без привязки к регистру.
	- `?P<day>`
	- `?P<hour>`
	- `?P<minute>`
	- `?P<second>`
- `.setByTemplate(template, str) -> self`  — извлечение из строки данных по шаблону.
	- `yyyy` - год
	- `MM` - месяц числом
	- `MMMM` - месяц текстом на английском или русском, сокращенно или полностью без привязки к регистру.
	- `dd` - день
	- `hh` - часы
	- `mm` - минуты
	- `ss` - секунды
- `.setChrono(Chrono) -> self`
- `.setQDateTime(QDateTime) -> self` — извлекает дату и время из PyQt.QDateTime.
- `.setQDate(QDate) -> self` — извлекает дату из PyQt.QDate.
- `.setQTime(QTime) -> self` — извлекает время из PyQt.QTime.
- `.setTimeZone("UTC") -> self` или сокр. `.setTZ()` — 

## Методы типа «transformator»
- `.shift(year, month, day, hour, minute, second, week) -> self` — изменяет содержимое в соответствии с переданными данными.
```python
c.shift(year = -56, month = 0, day = 30, hour = 0, minute = 49, second = 15, week = 2)

c.shift(week=-2) # смещает дату на 14 дней назад
```
- `.shiftTextCommand(str) -> self` или сокр. `.shiftTC(str)` — выполняет те же функции, что и `.shift()`, однако, команды задаются с помощью строки. Условные обозначения:
	- `1y` — год
	- `1mo` — месяц
	- `1d` — день
	- `1h` — часы
	- `1m` или просто число — минуты
	- `1y` — год
	- `1y` — год
```python
c.shiftTextCommand("-56y 30d 49 +15s +45s 2w")
```
- `.setTimeShift(str) -> self` или сокр. `.setTS(str)` — объединяет в себе функционал методов `.setTimeFromString()` и `.shiftTextCommand()`. принимают строку в которой сначала идет число/числа содержащие время, затем к нему применяется смещение.
```python
c.setTS("1545 +20") # → 16:05
c.setTS("14 +90") # → 15:30
c.setTS("16:45 +2h +15m") # → 19:00
```
- `.toUTC() -> self` — конвертирует содержащееся время в UTC
- `.toLocal() -> self` — конвертирует содержащееся время в локальное время компьютера
- `toTimeZone("UTC") -> self` — конвертирует время из текущей временной зоны в переданную

## Методы типа «getter»
- `.getDateTime() -> datetime.datetime`
- `.getDate() -> dateteme.date`
- `.getTupleDateTime() -> tuple`
- `.getTupleDate() -> tuple`
- `.getTupleTime() -> tuple`
- `.getISO() -> str` — получает строку с датой формата ISO (`"2022-11-15T00:15:45"`). Если текущий часовой пояс не UTC, то получаемый результат приводится к часовому поясу UTC.
- `.getUnixEpoch() -> int` — получает положительное или отрицательное число секунд прошеших с `1970-01-01 00:00:00`. Если текущий часовой пояс не UTC, то получаемый результат приводится к часовому поясу UTC.
- `.getDayYear() -> int` — день с начала года для текущей даты
- `.getWeekday() -> int` — день недели, где 1 это понедельник, а 7 — воскресенье.
- `.getDecade() -> int` — декада месяца в которую входит текущая дата. (1, 2, 3).
- `.getDecadeByYear() -> int` — декада с начала года в которую входит текущая дата
- `.getWeekYear() -> int` — неделя с начала года, начиная с первого понедельника
- `.getLastDayMonth() -> int` — получение последнего дня месяца или количество дней в месяце в которую входит текущая дата.
- `.getCentury() -> int` — получение века, в который входит текущая дата.
- `.getCenturyRome() -> str` — получение века, в который входит текущая дата римскими цифрами.
- `template(str) -> str` или сокр. `T(str)` — получение даты отформатированной по шаблону.
	- `yyyy` - полный год
	- `yy` - год без века
	- `MM` - месяц с нулем
	- `MMMM` - месяц текстом на английском (полный)
	- `MMM` - месяц текстом на английском (сокращенно)
	- `dd` - день с нулем
	- `ddd` - день недели текстом (сокращенно)
	- `dddd` - день недели текстом (полный)
	- `hh` - часы с нулем
	- `mm` - минуты с нулем
	- `ss` - секунды с нулем
	- `tz` - временная зона
- `.format(str) -> str` или сокр. `F(str)` — получение даты отформатированной по шаблону типа "%"
	- Сокращенный шаблон
		- `%YMD` → 2022-4-15
		- `%YMD0` or `%x` → 2022-04-15
		- `%YMD_` → 2022_04-15
		- `%HMS` → 2:15:0
		- `%HMS0` → 02:15:00
		- `%AMPM` → 2:15AM
	- год и век
		- `%Y` → 2022
		- `%y` → 22
		- `%c` — век (21)
		- `%cRome` — век римскими цифрами
	- месяц
		- `%m` → 5
		- `%m0` → 04
		- `%mE` or `%B` → April — полное название месяца на английском
		- `%mAE` or `%b` → Apr — сокращенное название месяца на английском
		- `%mR` → Апрель
		- `%mAR` → Апр
	- день и день недели
		- `%d` → 15
		- `%d0` → 15, но если бы был день 5, то 05
		- `%w` — день недели числом от 1 до 7, где 1 — понедельник.
		- `%wE` or `%A` — день недели на английском языке
		- `%wAE3` or `%a` — сокращенная запись дня недели до 3 символов на английском языке
		- `%wAE` — сокращенная запись дня недели до 2 символов на английском языке
		- `%wR` — день недели на русском языке
		- `%wAR3` — сокращенная запись дня недели до 3 символов на русском языке
		- `%wAR` — сокращенная запись дня недели до 2 символов на русском языке
	- время
		- `%H` → 2
		- `%H0` → 02
		- `%I` → часы в 12 часовом формате
		- `%M` → 15
		- `%M0` → 15
		- `%S` → 0
		- `%S0` → 00
	- кварталы, декады, недели
		- `%DEC` — декада месяца
		- `%DY` — декада с начала года
		- `%QUA` — квартал с начала года
		- `%W` — неделя с начала года
		- `%j` — дней с начала года
	- `%Z` — временная зона
```python
c.format("Start %Y, %d %wAE3")
#>>> "Start 2021, 15 Feb"
```

## Методы типа «analyzer»
- `.isLeapYear(int) -> bool` — является ли год содержащийся в Chrono високосным? Если в аргумент передается год, то анализ на високосность проводится с переданным годом.
- `isUTC() -> bool` — соответствует ли временная зона UTC?
- `isLocal() -> bool` — соответствует ли временная зона локальному времени компьютера?
- `isTimeZone(str) -> bool` — соответствует ли временная зона переданной?

## Управление временными зонами
По умолчанию временная зона создаваемого объекта соответствует временной зоне компьютера (`'local'`). 

Исключение! Если данные задаются с помощью методов `.setISO()` и `.setUnixEpoch()`, то временная зона автоматически переводится в `UTC`.

Задать вручную временную зону можно при создании `Chrono` или с помощью метода `.setTimeZone(string)`.
```python
c1 = Chrono(2021, 2, 15, tz = "UTC")
c2 = Chrono(2021, 2, 15).setTimeZone("UTC")
```
↑ никак не изменяет содержимое `Chrono`.

Методы трансформации Chrono на основании часового пояса.
- `.toUTC() -> self` — конвертирует содержащееся время в UTC
- `.toLocal() -> self` — конвертирует содержащееся время в локальное время компьютера
- `toTimeZone("UTC") -> self` — конвертирует время из текущей временной зоны в переданную

Так же можно проверить является содержит ли 
- `.isUTC() -> bool`
- `.isLocal() -> bool`
- `.isTimeZone("UTC") -> bool`

Получить все доступные временные зоны можно:
- `.getAllTimeZone() -> list`

## Операторы
- `<`
- `>` 
- `==` 
- `<=`
- `>=`
- `!=`

Вычитая один объект chrono из другого возвращается объект pchrono, содержащий период двух дат.

# INTERVAL
```python
from interval import Interval
from interval import Intervals
```

Interval — представляет два даты Chrono в виде интервала, в котором одна дата является началом интервала (`Interval.s`), а другая — концом (`Interval.f`) и предоставляет методы для операций над интервалом.

Interval содержит следующие параметры
- `s` — Chrono обозначающий начало интервала
- `f` — Chrono обозначающий конец интервала
- `expand` — разрешено ли расширение интервала (`True`/`False`)? Если  запрещено расширять интервал, то при необходимости вписаться в заданный в `roundOff` временной период интервал будет сворачиваться во внутрь. При сворачивании во внутрь, если изначально заданный интервал недостаточно большой, может возникать ошибка
- `roundOff` — способ расширения или сужения интервала. 
	- `"decennary"` — округляет интервал до десятилетия. 
	- `"year"` — округляет интервал до года. 
	```
	ПРИМЕР start = <2022-10-25 12:45>, finish = <2022-11-26 4:35>
	
	expand=True → <2022-01-01 00:00:00 — 2023-01-01 00:00:00>
	expand=False → <2023-11-01 00:00:00 — 2022-11-01 00:00:00> ← error
	```
	- `"quarter"` — округляет интервал до квартала года
	- `"month"` — округляет интервал до месяца
	- `"decade"` — округляет интервал до декады
	- `"week"` — округляет интервал до недели, где начало — понедельник.
	- `"day"` — округляет интервал до дня
	- `"hour"` — округляет интервал до часов
	- `"minute"` — округляет интервал до минут
	- 
- `about` — пустая переменная никак не участвующая в работе самого интервала. В нее могут быть записаны любые данные описывающие интервал.
- `fragments` — список интервалов являющиеся частью данного интервала. Например интервал `неделя` может содержать 7 фрагментов-интервалов `день`.

## Создание Interval
```
Interval(s = None, f = None, roundOff = None, expand=True, about=None)
```

```python
i = Interval()
# ↑ будет создан интервал текущего дня

# ↓ в интервал могут быть переданы любые данные, которые сможет «переварить» метод Chrono.set()
i1 = Interval("2022-12-15", "2022-12-16")
i2 = Interval((2022, 12, 15), "2022-12-16")
i3 = Interval(Chrono(2022, 12, 15), "2022-12-16")

i = Interval("2022-12-15")
# ↑ Если будет передано только одно значение, то Interval попытается его расширить со значением `roundOff="day"`, если иного значение в roundOff передано не было. Так же принудительно будет выставлен параметр `expand=True`.
```

Если временная зона начала интервала отличается от временной зоны окончания интервала, то окончание интервала приводится ко временной зоне начала интервала.

## Методы Interval
- `.isChronoInto(Chrono) -> bool` — является Chrono частью данного интервала?
- `.isIntervalInto(Interval) -> bool` — является ли Interval частью данного интервала? Переданный период не может выходить за границы текущего.
- `.isIntervalLayered(Interval) -> bool` — закрывает ли переданный интервал хотя бы часть текущего интервала? 
- `.setFramentation(*intervals) -> self` — задает список интервалов для self.fragments. Из переданного списка исключаются интервалы не являющиеся частью данного интервала. Интервалы входящие частично в данный интервал — обрезаются.
- `.getСompleted(Chrono) -> float` — определяет процент завершенности текущего периода на основании переданной даты
- `.getOccupancy() -> float` — выдает процент заполненности текущего интервала интервалами из self.fragments.
- `.getDuration(measure='second')` — определяет длительность интервала. По умолчанию выдает длительность в секундах, но может быть выдана и в `"minute"`, `"hour"`, `"day"`. Так же может быть передан dict с распределением по дням, часам, минутам, секундам и годам, где год имеет фиксированное значение 365 дней независимо от високосности.
- `.fragmentation(frag="day")` — фрагментирует текущий интервал на интервалы размер которых задан в параметре `frag`. Параметр `frag` принимает теже параметры, что и `roundOff` у Interval. Результат записывается в self.fragments.
- `.step(st=0)` — «шагает» по интервалам в зависимости от roundOff. Например, если `roundOff="day"`, а `st=-1`, то интервал трансформируется во вчерашний день. Если `roundOff=None`, то интервал будет «шагать» ориентируясь на свою длину.
- `.join(Interval, greedy=False)` — объединяет два интервала. Если `greedy=False`, то два интервала объединятся только если они хотя бы частично входят друг в друга. Если `greedy=True`, то для объединения берутся две крайние точки и пропуск между ними так же включается в состав нового интервала.
- `.template(template) -> str` или сокр. `.T(template)` — предоставляет возможность воспользоваться методом `Chrono.template()` из Interval. Передаваемый шаблон нужно оформить следующим образом:
```
START[[yyyy-MM-dd hh:mm:ss]] — FINISH[[yyyy-MM-dd hh:mm:ss]]"
```

## Методы Intervals
Intervals — предоставляет методы для операций над списками интервалов.

```python
ins = Intervals(list_itervals)
```

- `.skip() -> list` — создаст список пропущенных интервалов, которые могут быть вписаны между
- `.join() -> list` — интервалы между которыми не существует пропусков объединяются в один интервал. Выдается список объединенных интервалов.
- `.sum(measure='second') -> float` — суммирует длительность всех интервалов
- `.occupancy(measure='second') -> float` — суммирует длительность всех интервалов учитывая наслаивание интервалов друг-на-друга. Наслаивающиеся части интервалов не будут учитываться по нескольку раз.